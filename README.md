# 1장. 깨끗한코드
## TIL
- 사소한 것은 중요하다. 이 책은 사소한 듯 보이나 실제로는 사소하지 않은 내용을 다룬다.
- 장인 정신을 익히는 과정 = `원칙`, `패턴`, `기법`, `경험` 이라는 지식 습득 + 지식을 몸과 마음으로 체득 ( 깨끗한 코드를 작성하는 방법 = `원칙`, `패턴` 습득 + 고생)
- 실제로는 코드의 종말이 코앞에 닥쳤다고 주장하는 사람이 없지 않다.
  - 코드를 자동으로 생성하는 시대가 다가옴.
  - 프로그래머는 필요가 없다?
  - 아니다, 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능 -> 코드는 사라질 수 없다.
- 대충 짠 프로그램이 돌아간다는 사실에 안도하지 말자 -> 나중은 결코 오지 않고, 생산성은 최악이 된다.
- 프로젝트 실패는 나에게도 책임이 있다. 상사가 시키는대로만 하지 말아라 -> 환자가 의사에게 바쁘니 수술 전에 손을 씻지 말라고 해서 과연 그렇게 할 수 있을까? 환자 말을 그대로 따르는 행동은 전문가 답지 못하다.
- 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. *-그래디 부치(Grady Booch)-*
- 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들자 

## 오늘 읽은 소감은?
- 과거에 예측했던 대로 현재 시대는 AI가 도래하였고, ChatGPT와 함께라면 비개발자도 개발할 수 있는 시대가 왔다고 다들 말한다.
- 나는 이 얘기는 반은 맞고 반은 틀리다고 생각한다. 일부 개발자는 대체 될 수도 있지만, 그렇지 않은 개발자는 분명 살아남을 것이다.
- 나는 `AI가 대체할 수 없는 그런 개발자`이고 싶다. => 고객이 요구사항을 모호하게 줘도 환경과 상황에 맞춰 요구사항을 알맞게 분석하고 니즈를 파악할 수 있는 그런 개발자가 되자. 
- 내 직업에 자부심과 내 코드의 책임감을 갖고 사소한 것에 휘둘리지 않으며 아름답고 깨끗한 코드를 그대로 유지할 수 있는그런 개발자가 되고싶다.
<br/>
<br/>

# 2장. 의미있는 이름
## TIL
- **의도를 분명히 밝혀라**: 이름을 지을 때는 이름에 정보 제공을 충분히하여 이해하기 쉽게 만들어라.
  - ex. int d; (X)  int elapsedTimeInDays; (O)
- **그릇된 정보를 피하라**: 예약어 사용X, 흡사한 이름 사용X, 유사한 개념은 유사한 표기법 사용, 일관성이 떨어지는 표기법은 그릇된 정보이다
  - ex. int o = l; (X) // 숫자 1은 문자 l 처럼 보이고, 문자 o는 숫자 0처럼 보인다. 
- **의미있게 구분하라**: 읽는 사람이 차이를 알 수 있도록 만들어라(불용어를 추가하여 아무런 정보를 제공하지 못한다면 붙일 이유가 없다)
  - ex. Customer/CustomerObject, moneyAmout/money, customerInfo/customer, accountData/account, theMessage/message => 전부 다 왼쪽 오른쪽 특별하게 구분이 안됨. 불용어가 의미가 없음.
- **발음하기 쉬운 이름을 사용하라**: 발음을 알려줄 필요도, 설명도 필요없게 만들어라
  - ex. genymdhms는 generate date, year, month, day, hour, minute, second라는 뜻이고 "젠 야 무다 힘즈" 라고 읽어야 됩니다라는걸 새로운 개발자가 올때마다 알려줘야하니 비효율적이다
- **검색하기 쉬운 이름을 사용하라**: 변수이름이나 상수를 문자하나로 짓는다면, 검색했을 때 엄청난 양이 나온다. 긴 이름이 짧은 이름보다 좋고, 검색하기 쉬운 이름이 상수보다 좋다.
  - ex. 그냥 5라고 적는것 (x) WORK_DAYS_PER_WEEK = 5 (O) => 더 찾기도 쉽고 의미 파악도 쉽다.
- **인코딩을 피하라**: 인코딩할 정보는 불필요하다. 불필요한 접두어는 쓰지말자.
  - ex. m_dsc(X) / description (O), ShapeFactoryImp (O) / IShapeFactory (X)
- **자신의 기억력을 자랑하지 마라**: 이름은 명료해야하고, 누군가 해석이 필요한 이름은 안된다.
- **클래스이름**: 명사 또는 명사구 (동사X)
  - ex. Customer, WikiPage, Account, AddressParser (O) / Manager, Processor, Data, Info (X)  
- **메서드이름**: 동사 또는 동사구
  - ex. postPayment, deletePage, save (O)  
- **기발한 이름을 피하라**: 재미난 이름보다는 누구나 다 이해할 수 있는 명료한 이름을 선택해라.
- **한 개념에 한 단어를 사용하라**: 일관성있게 같은 개념은 같은 단어를 사용하자
  - ex. controller, manager, driver를 섞어 쓰지 말고, controller 하나로 통합하자 => DeviceController, ProtocolController
- **말장난을 하지마라**: 한 단어를 두가지 목적으로 사용하지 마라.
  - ex. add라는 의미가 변수 두개를 더하는 목적의 의미라면, 이 목적 외에 다른 목적 (리스트에 값을 추가)에 add를 사용하지 말아라.
- **해법 영역에서 가져온 이름을 사용하라**: 프로그래머가 알만한 전산 용어, 알고리즘 이름, 패턴 이름, 수학용어를 적극 활용하자
  - ex. JobQueue (O)
- **문제 영역에서 가져온 이름을 사용하라**: 적당한 프로그래머 용어가 없다면, 해당 도메인/전문분야의 용어를 사용해라.
- **의미있는 맥락을 추가하라**: 여러 곳에서 쓰일 수 있어 맥락 파악이 힘든 단어라면 접두어를 붙이거나, 메서드를 쪼개서 맥락파악을 쉽게 만들어라.
  - ex. state => 상태인지, 주소의 '주' 인지 알 수 없음 / addrState라고 한다면 주소에서 '주'를 의미한다는걸 알 수 있음
- **불필요한 맥락을 없애라**: 일반적으로 짧은 이름보다는 긴 이름이 좋지만, 의미가 분명한 경우에는 굳이 불필요한 맥락을 추가하지 말자.
<br/>

## 오늘 읽은 소감은?
- 의미있는 이름을 짓는건 생각보다 어려운 일인 것 같다.
- 내가 어림짐작해서 쓰고 있었던 이름들 중에 잘못된 이름이었다는걸 이 책을 읽으면서 깨달았다. 그리고, 가끔씩은 다른 개발자들의 이름을 보면서 혁신적이다라고 생각하고 따라 쓴 경우도 있었는데 그것 또한 좋은 이름이 아니였다.
- (처음에는 익숙하지 않고 어렵겠지만) 이름을 지을 때 여기에 나온 조언들을 기반으로 이름을 짜는 습관을 가져야겠다.
 <br/>
 
## 이 책을 읽는 이유?
<img src="https://github.com/Narae-H/clean-code/blob/main/slack.png?raw=true" width="700px" alt="클린코드를 읽는이유"/>
<br/>
<br/>

# 3장. 함수
## TIL
- 함수는 같은 단계의 추상화 수준으로 묶여 한 가지 일만을 해야하며 그 크기는 작으면 작을수록 더 좋다. (높은 추상화 수준: What, 낮은 추상화 수준: How)
- 코드는 위에서 아래로 이야기처럼 읽혀야하므로 이해하기 쉽도록 하나의 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 위치하게 만든다.
- 함수 이름은 함수의 행위를 알수있게 서술적인 이름으로 작성하여아하며, 함수와 인수가 동사/명사 쌍을 이룬다.
- 함수 인수(Argument)는 이상적인건 0개. 4개 이상이 될 경우, 성격이 비슷한 인수를 묶어서 클래스화하여 인수의 개수를 줄여라.
- 함수의 이름을 지어놓은 대로의 기능이 아닌 다른 기능을 몰래 넣어놓지 말아라.
- 초안은 대개 서투르고 어수선하므로 여러 번의 수정 과정을 거쳐서 체계가 잡힌 코드(이야기)를 만들어라.

## 오늘 읽은 소감은?
- 함수 부분은 생각보다 내가 놓치고 있는 부분이 많았다. 그래서 그런가 이틀동안은 책이 쑥쑥 읽혔는데, 함수 부분은 버벅이면서 읽었다.
- 사실 90%이상 이해했다고 보기도 힘들어서 여러번 반복해서 읽고 연습하는 과정이 필요할 것 같다.
- 무엇보다 `추상화 레벨`을 파악하고 함수를 작성하는 부분은 개발을 할 때 계속해서 인지하여야 할 부분인 것 같다.
- 이 부분을 계속 생각하면서 개발을 하고 나중에 다시 함수파트를 읽었을 때는 이해하지 못했던 다른 부분을 발견할 수 있음 좋겠다.
<br/>
<br/>

# 4장. 변수
## TIL
- 애초에 주석이 필요없는 방향으로 코드를 짜자.
- 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
- 좋은 주석: 저작권 정보, 소유권정보, 결과를 경고, TODO 주석, 중요성을 강조하는 주석
- 나쁜 주석: 같은 이야기를 반복, 부정확, 의무적으로 다는 주석, 코드관리 시스템에 써야 할 주석, 닫는 괄호에 다는 주석, 주석으로 처리한 코드, HTML로 쓰여진 주석

## 오늘 읽은 소감은?
- 책을 읽으면서 모르는 내용을 찾다가 `TODO` 주석을 발견했고, VS Code에서 사용해 봤는데 굉장이 유용해 보인다.
- 내가 유용하다고 생각했던 주석 중에 일부는 나쁜 주석의 예시로 나와서 당황스러웠다. 예를 들어, HTML 주석 같은 경우 좋은 주석이라고 생각했는데 이것도 가독성을 떨어뜨리는 나쁜 요소가 될 수 있다니 신기했다.
- 사실 주석이라는게 당장 코드에는 아무런 영향이 미치지 않으니, 프로덕션 직전까지는 무분별하게 썼었는데(물론 프로덕션 모드에서도 완벽한 주석이라고 자부할 수는 없다) 반성하는 계기가 되었다.
- 유명한 프로그램 조차 주석에서 실수를 범한다는건 개발을 하는 대다수의 사람들이 나처럼 주석의 중요성을 간과한게 아닐까?
- 비록 책의 도입부 정도밖에 읽지 않았지만 책을 읽을수록 사소한 습관이 얼마나 중요한지를 깨닫게 되는 중이다.
- 
## 최애 독서 감상문
- [최애 도서 감상문1](https://hushkmj.tistory.com/136): 간결하게 잘 정리한것 같다.
- [최애 도서 감상문2](https://blog.naver.com/kwakky1): 책 내용은 다소 딱딱할 수 있지만, 뭔가 가볍게 정리된 느낌이라 좋았다.
- [최애 도서 감상문3](https://velog.io/@seulpace/clean-code-01): 가독성이 좋고 잘 정리되어 있다.
<br/>
<br/>

# 복습 & 과제
## 오늘의 과제
- 오늘의 책 읽기: 복습
- 오늘의 과제: 더러운 코드를 고쳐라!

## 과제
### QUIZ 01
#### Q: 아래 코드를 깨끗하게 다시 작성해 주세요.
- Hint❕ : 검색하기 쉬운 이름을 사용하세요.
- blastOFF는 로켓 발사를 의미. 86400000은 하루의 밀리초 (milliseconds) 의미.
```js
// What the heck is 86400000 for?
setTimeout(blastOff, 86400000);
```
#### A:
```js
const MILLISECONDS_IN_A_DAY = 60 * 60 * 24 * 1000; //86400000;
setTimeout(blastOff, MILLISECONDS_IN_A_DAY);
```

#### 이렇게 코드를 작성한 이유: 
- p.28에보면 `검색하기 쉬운 이름을 사용하라` 라는 부분이 있다.
- 문자는 눈에 잘 띄고 이해하기 좋으며 검색도 쉽지만, 숫자 그 자체는 눈에 잘 띄지도 않고 어떤 의미로 쓰였는지 의도 파악도 힘들며 검색도 어렵다. 
- 또한 숫자가 변동되었을 경우 정확한 의도 파악도 힘들고 알아차리기도 어렵기 때문에 버그를 일으키기도 좋다.
- 때문에 숫자를 `의미있는 변수`에 담고, 상수라는걸 명시하기 위해 `대문자로 표기`하였다.
<br/>

### QUIZ 02
#### Q: 아래 코드를 깨끗하게 다시 작성해 주세요.
- Hint❕ : 의미있는 이름을 사용해 주세요.
```js
const yyyymmdstr = moment().format("YYYY/MM/DD");
```
#### A:
```js
// 방법1: 변수 이름만을 변경
const currentDate = moment().format("YYYY/MM/DD");

// 방법2: 용도를 몰라 일반적으로 작성하되, 상수로 날짜 타입정의 
const DATE_FORMAT_WITH_SLASH = "YYYY/MM/DD";
const formattedToday = moment().format(DATE_FORMAT_WITH_SLASH);

// 방법3: 특정 용도로 쓰인다고 가정
// 아래 포맷은 구글맵 API를 쓰기 위해 사용
const GOOGLE_MAPS_API_DATE_FORMAT = "YYYY/MM/DD";
const googleApiRequestDate = moment().format(GOOGLE_MAPS_API_DATE_FORMAT);
```

#### 이렇게 코드를 작성한 이유: 
- p.25에서 `의도를 분명히 밝혀라`라는 부분이 있다.  
- 변수 이름이 발음하기 쉬운 이름이면서도 오늘 날짜라는 의미가 담겨있으면 했다. 또한, 포맷에 초점을 둘것인지, 역할에 초점을 둘것인지, 왜 이 변수가 필요한지, 다른 변수와 어떻게 구분할지 고민해봤다.
- 가장 고민했던 부분은 해당 날짜 포맷이 `YYYY/MM/DD`라는걸 변수에 표기할까 말까였다. 몇 가지 시나리오를 생각해봤다.
  - 포맷을 변수에 나타내줘야 한다면 `YYYY/MM/DD`라고 넣는게 맞는거 같은데, 변수에는 `/`를 사용할 수 없다. (YYYY/MM/DD는 YYYYMMDD랑 다르니 구분이 필요하다)
  - 코드가 길어졌을 때를 대비해서 변수만 보고도 포맷을 확인할 수 있는게 좋을까 아님 의미가 없을까?
  - 이 코드에서는 날짜의 포맷이 중요할까? 단순히 로그 출력을 위해서 사용하는거나, 특정한 API 사용을 위한 용도라 포맷을 굳이 명시하지 않아도 된다면?
- 여기서는 코드의 극히 일부분만을 보여줬기 때문에 용도를 정확히 파악하긴 어렵다. 하지만 전박적으로 데이터 포맷이 쓰이는 경우를 고려한다면, `YYYY/MM/DD`는 특정 모듈/API에서 공통적으로 쓰이는 포맷일 것이다.
- 따라서, `데이터 포맷 상수`를 변수에 저장하여 해당 포맷의 사용처를 밝히고, momemt()에서 쓰인 변수는 이름에 포맷을 넣지않고 역할만을 드러내는게 좋다고 생각했다.
<br/>

### QUIZ 03
#### Q: 아래 코드를 깨끗하게 다시 작성해 주세요.
- Hint❕ : 불필요하게 반복하지 마세요.
```js
const Car = {
  carMake: "Honda",
  carModel: "Accord",
  carColor: "Blue"
};

function paintCar(car, color) {
  car.carColor = color;
}
```
#### A:
```js
const car = {
  make: "Honda",
  model: "Accord",
  color: "Blue"
};

function paintCar(car, color) {
  car.color = color;
}
```

#### 이렇게 코드를 작성한 이유: 
- p.37에서 `불필요한 맥락을 없애라`라는 부분이 있다.  
- 이미 객체를 생성할때 이름을 `Car`라고 했는데도 불구하고 attribute마다 `car`를 접두사를 다시 붙이는건 불필요하다.  
- 일반적으로 변수는 소문자로 시작하며, 대문자로 시작하는 경우는 클래스 이름, 생성자 함수등 특별한 역할을 가진 객체를 구분하기 위해 사용된다. 따라서, car 변수를 대문자로 시작하는건 옳지 않다. 
- `make`가 동사고 일반적이지 않다고 생각하여 `brand`로 바꿀까 고려했었지만 그대로 유지하였다.
  - `make of the car`가 자동차의 제조사를 나타낸다.
  - p.34에서 `문제 영역에서 가져온 이름을 사용해라: 적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져온다.`라는 걸 고려할때 해당 문제가 자동차 도메인이라면 make를 쓰는게 맞다고 보인다. 
<br/>
<br/>

# 5장. 형식 맞추기 
## TIL
- 형식을 맞추는 이유: 코드는 변경될지라도 개발자의 스타일, 규율, 가독성은 사라지지 않는다.
- 적철한 행 길이를 유지하라: 큰 파일보다는 작은 파일이 이해하기 쉽다
  - 신문기사처럼 작성하라: 이름은 간단하면서도 설명이 가능하며, 아래로 내려갈수록 의도를 세세하게 묘사한다. 또한, 짧게 작성해라.
  - 개념은 빈행으로 분리하라: 빈행은 새로운 `개념`을 시작한다는 시각적 단서다.
  - 세로 밀집도: 세로 밀집도는 `연관성`을 의미한다. 서로 밀집한 개념은 (쓸모없는 줄바꿈 없이) 가까이 있어야 한다.
  - 수직거리: 변수는 사용하는 위치에 최대한 가까이 선언, 인스턴스 변수는 클래스 맨 처음에 선언, 호출하는 함수를 호출되는 함수보다 먼저 배치
- 가로형식: 120자 정도로 행길이 제한이 바람직
  - 가로 공백과 밀집도: 연관이 있을 경우 붙여쓰고(ex. 함수이름과 파라미터 부분), 강조하기 위해서는 띄어쓴다(할당 연산자)
  - 가로 정렬: 굳이 변수 선언 부와 할당 부분을 정렬할 필요가 없다. 오히려 중대한 결함을 찾기 힘드므로.
  - 들여쓰기: 들여쓰기 정도는 계층에서 코드가 자리잡은 수준
- 팀규칙: 팀은 한가지 규칙에 합의하여야 하며, 그 규칙은 일관적이고 매끄러워야 한다.

## 오늘 읽은 소감은?
- 가독성을 높히기 위해서는 사소한 띄어쓰기 하나도 중요하다는 사실을 다시 한 번 깨닫게 되었다.
- 그리고, 팀 내 규칙이 일관적이고 모든 팀원들이 그것을 따를 때 코드가 비로써 아름다워지리라.
<br/>
<br/>

# 6장. 객체와 자료 구조 
## TIL
- 자료 추상화: 
  - 구현을 감추려면 자료 추상화가 필요하다.
  - 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하여 사용자가 구현을 모른채 자료의 핵심을 조작할 수 있어야 한다.
  - 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야한다.
- 자료/객체 비대칭: `자료`와 `객체` 두 정의는 본질적으로 상반되므로, 개발자는 두 정의를 명확히 이해하고 **적절한 상황에서 올바르게 사용하는 것**이 중요
  | <center>**구분**</center> | <center>**정의**</center>            | <center>**사용 목적**</center>        | <center>**예시**</center>             |
  |---------------------------|-------------------------------------|--------------------------------------|---------------------------------------|
  | <center>**자료**</center> | 별다른 동작 없이 데이터를 그대로 노출  | 새로운 **함수**가 필요한 경우 유용      | DTO (Data Transfer Object), Bean 구조 |
  | <center>**객체**</center> | 동작(메서드)을 공개하고 데이터를 숨김  | 새로운 **데이터 타입**이 필요한 경우 유용| 클래스와 메서드 중심 설계              |
- 디미터 법칙: 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
<br/>
<br/>

# 7장. 오류처리 
## TIL
- 오류코드보다는 `예외`를 사용: 오류코드는 호출자 코드가 복잡해짐 -> 호출자 코드에다가 오류코드 별로 하나 하나 조건문을 작성해야 하고 잊어버리기도 쉬움.
- `Try-Catch-Finally` 문부터 작성: try-catch구문을 사용하여 예외처리를 먼저 정의하고 점진적으로 필요한 로직을 추가.
- `미확인 예외`(Unchecked Exception): 최하위 함수에서 에러가 발생한다고 상위 단계 메서드를 전부 try-catch/throws 를 사용하여 고쳐야한다면 비용 증가.
  - ❌ 잘못된 미확인 예외 처리법: `try-catch` 사용
  ```java
  try {
    int result = 10 / 0; // ArithmeticException 발생
  } catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다.");
    throw e;
  }
  ```
  - ✅ 올바른 미확인 예외 처리법: `사전 검증 코드` 추가
  ```java
  int divisor = 0;
  if (divisor != 0) {
    int result = 10 / divisor;
  } else {
    System.out.println("0으로 나눌 수 없습니다.");
  }
  ```
> <details>
>
> <summary> <small>확인된 예외(Checked Exception) VS 미확인 예외(Unchecked Exception)</small> </summary>
>
> | 구분 | Checked Exception | Unchecked Exception |
> |------|------------------|------------------|
> | **예외 처리 필수 여부** | ✅ 강제됨 (`try-catch` or `throws` 필요) | ❌ 개발자 선택 |
> | **컴파일 타임 감지** | ✅ 감지됨 | ❌ 감지되지 않음 |
> | **대표 예외** | `IOException`, `SQLException` | `NullPointerException`, `ArrayIndexOutOfBoundsException` |
> | **사용 목적** | 외부 환경(파일, DB 등)에서 발생하는 예외 처리 | 주로 개발자의 실수 방지 |
> </details>

- `특수 사례 패턴`(Special Case Pattern) 사용:
  - `null`을 반환할 가능성이 있다면 호출자는 무조건 `null 체크`를 해야 하며, 그렇지 않으면 `NullPointerException`이 발생할 수 있음.
  - 이때 특수 사례 패턴을 사용하여, `null` 대신 특정한 `빈 객체`를 반환하여 안전한 처리를 도와줌.
  ```java
  public class UserService {
    public User findUserById(String id) {
      if ("admin".equals(id)) {
        return new User("admin", "Admin User");
      }
      return new User("unknown", "Unknown User"); // ✅ null 대신 빈 객체 반환
    }
  }
  ```
- `감싸기 메서드`(Wrapping Method): null 체크, 예외 처리 등의 공통 작업을 감싸는 메서드를 만들어서 재사용

## 오늘 읽은 소감은?
- 처음에 Java 공부를 했을 때, 교수님께서 자바에서 에러의 대부분은 NullPointerException 이라고 말씀했던게 기억이 난다.
- 자주 발생하는 에러인 만큼 '어떻게 잘 방지할까'에 대해서 심도있게 생각해 본적은 없었는데 이 기회에 한번 집고 넘어가게 되서 좋았다.
- 개발을 하다보면 그냥 막연하게 익히고 사용하는 습관들이 있는데(ex. null을 반환하지 않게 조심하는 그런 습관), 그런 것들이 어떠한 용어를 가지고 있고 일정한 개발 패턴(?)에 의해서 쓰이고 있다는 것을 알게되니 신기하다. 

## 공부법 공유
<img src='https://github.com/Narae-H/clean-code/blob/main/how%20to%20study.png?raw=true' width='90%'/>
<br/>
<br/>

